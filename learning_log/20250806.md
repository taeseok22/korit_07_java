# cord convention 관련

```java
import java.util.Scanner;

public class PersonMain {
    public static void main(String[] args) {
        // 사용할 외부 및 내부 클래스 목록들 전부 import 해옴
        Scanner scanner = new Scanner(System.in);
        Array08 array08 = new Array08();
        // 사용하는 변수 목록들 전부 선언
        int randomNum;
        double[] scores = new double[25];
        String[] students = new String[25];
        // ... 
        // 막 내부 로직들 엄청나게 써놓고 있다고 가정하다가
        // 저 밑에서 갑자기 
        // students가 튀어나왔다고 가정해보겠다.
        if (randomNum < 0)
        {
            // 이런 방식으로 실행문을 써야 한다. 라는 식으로 회사에서 정하는 경우가 있다.
        }
    }
}
```

# 상속(Inheritance)
    - 객체지향프로그래밍(OOP)의 핵심 개념 중 하나로, 기존 클래스(부모(슈퍼)클래스)의 
    - field와 method를 재사용해 새로운 클래스(자식(서브)클래스)를 만드는 것을 의미함.

# 상속의 필요성
    - 상속을 통해 공통적인 기능을 부모 클래스에 정의하고 이를 '여러' 자식 클래스가
    - 재사용 가능
---
    - 동물(Animal) 클래스가 있고 이를 상속 받는 개(Dog) / 고양이(Cat) 클래스가 있다고
    - 가정했을 때 동물의 공통적인 field(이름 / 나이 등)와 행위(걷기 / 먹기 등)을
    - 부모 클래스에 정의 개와 고양이는 각각 고유한 특성(짖기 / 우다다다)을 추가할 수 있음
---
    - 이상의 과정을 거쳤을 때 얻을 수 있는 이점 : Dog에 이름 / 나이 / 걷기 / 먹기 / 짖기를 정의하고
    - 또 Cat 에다가 이름 / 나이 / 걷기 /먹기 / 우다다다를 정의하는 등의 공통된 부분을
---
    - 정의하는 일 없이 특정 field 및 메서드만 정의하면 된다. -> 중복된 코드를 줄일 수 있다.

# 상속의 특징
1. 단일 상속
    - Java는 단일 상속만 지원함. 하나의 클래스는 한 번에 하나의 부모 클래스만 상속 받을 수 있어
    상속 구조가 간단하고 명확함.
2. super 키워드
   - 클래스의 생성자 및 setter 에서 학습한 this와 유사한 개념으로
   부모 클래스의 field에 접근하거나 부모 클래스의 생성자를 호출할 때 사용함(두 가지 사용법이 있다.)
3. _method override_
    - 자식 클래스에서 부모 클래스의 기본 동작을 `재정의` 할 수 있음. 이를 통해 자식 클래스는 부모
    클래스의 기본 동작을 자신만의 방식으로 변경 가능
- 예시
    - Animal 클래스의 걷기를 Dog가 상속 받고 네 발로 걷기로 `재정의` , Human 클래스가 걷기를
    상속 받고 두 발로 걷기로 `재정의` 가 가능하다.
4. final 키워드 - 클래스에 final이 붙으면 상속 불가
    - method에 final이 붙으면 메서드 오버라이딩 불가능

## 장점
1. 코드 재사용성 - 동일한 코드를 반복적으로 작성할 필요 x
2. 유지 보수의 용이성
    - 부모 클래스의 변경 사항이 자식 클래스에 자동으로 반영되서 위계 파악 후 수정하면 된다.
3. 객체 간 관계 표현 - IS-A 관계를 명확히 나타냄.
    - IS-A
   '개'는 '동물'의 일종이다. 와 같은 예시로 IS-A는 is a kind of의 축약어
    - 그래서 우리가 미리 만들어온 Animal / Tiger / Human의 클래스를 예로 들었을 때
   Human / Tiger는 Animal 클래스의 자식(서브) 클래스다.

# 향상된 for문
        향상된 for문(Enhanced For Loop)

    일반 for 문과의 차이점
        일반 for 문의 경우 index 넘버(주소지)를 명확하게 알고 있어야 하지만
        일일이 element의 숫자를 세는 것이 번거롭기 때문에
        arr01.length와 같은 방식으로 일종의 field 참조를 통해 int 값을 추출해
        대입해야만 했다.

        근데 잘 생각해보면 for (int i = 0 ; ...) 부분에서 int i 는
        for문 내부에서 선언되고 내부에서만 사용이 가능하다.

        이를 응용하여 배열 내의 element에 for문 내부에서만 사용하는 변수에 대입하는
        방식으로 index 넘버(주소지)의 사용없이 적용할 수 있는 for 반복문이 있는데
        이를 향상된 for문이라고 한다.

    제약 :
        일기만 되고 쓰기가 안된다.(1부터 100까지 추출하는건 되는데 집어넣는건
        제한적으로 된다 등)

    형식 :
    for(자료형 변수명 : 반복가능객체(배열)) {
        반복실행문
    }
            // 향상된 for문으로 출력
        for (int number : nums) {   // int[]
            System.out.print(number + " ");
            // 첫 번째 반복에서 nums의 첫 번째 element인 1을 number에 대입
            // 즉 number = 1; 이 된 상황 -> 어디서 ? 40번 라인에서
            // 대입이 된 상태로 41번 라인을 실행시킨다. "1 " 까지 출력된다.
            // 그 다음 반복으로 넘어가서 nums의 두 번재 element인 2를 number에 대입
            // 41번 실행
            // 다음 3 대입
            // 41번 실행
            // ... 200 대입
            // 41번 라인 실행하고, 마무리(마무리 시점은 마지막 element 대입후
            // 반복 실행문 실행 후)
            // 이후에 반복문 바깥에서는 int i 와 동일하게
            // number 변수를 사용할 수 없다.
        }

# 배열 
        배열의 출력
    엄밀히 말자하면 저희는 배열을 출력한게 아니라 여태까지 배열 내부의 element 들을 출력했다.
    System.out.println(arr01); 과 같은 출력문을 작성했을 때
    주소값만 나온다는 사실을 확인할 수 있었다.

    근데 element의 값을 조정하거나, 더하거나와 같은 추가적인 가공을 하기 위해서 for 반복문을
    사용해왔는데 굳이 변형이 없고 배열 자체를 확인하고 싶을 때 마다
    main에 반복문 작성하든지 method를 정의하든지 하는 일은 번거로운 일이 된다.

    Arrays 클래스를 사용하고, '정적' 메서드인 .toString(배열명)을 사용하면
    배열 전체를 출력할 수 있다.

    여기서 우린 클래스명.메서드명() 이라는 점에 주목할 필요가 있다.
    scanner.nextLine()과는 다르다.
    그리고 toString() 이라는 메서드도 곧 사용하게 된다.

    여기서 중요한건 동일한 method 명이라 하더라도 어떤 클래스에 종속되어있는가에 따라
    다른 결과값을 지닐 수 있다는 점이다.
---
    이상의 경우는 보면 sort() 메서드에 오름차순에서는 argument가 하나였는데
    내림 차순할 때는 보니까 argument가 두개다.
    이상의 과정이 overloading이 이뤄졌다는 점을 파악할 수 있으면 현재 수준으로는
    만족이다.
    그리고 두번째 argument로 Comparator.reverseOrder(); 가 사용 됐는데
    Comparator.reverseOrder(); 결과값 / return값이 sort() 메서드의
    두번째 argument로 사용됐다는 점에서 역시 함수형 프로그래밍의 일종이라고
    볼 수 있다.
    근데 Comparator.reverseOrder(); 메서드를 쓰려면
    기본 자료형(원시 자료형 / primitive type) int[] 배열을 사용할 수 없어서
    Integer[] 배열을 사용했는데 현재는
    char -> String 처럼 int -> Integer 라고만 생각해두면 된다.
---
    다차원 배열(Muti-Dimensional Array) 중에서 2차원 배열

    : 다차원 배열은 2차원 이상의 배열을 의미하지만, 개발 환경 상
    2차원 배열 이상을 다루는 경우는 극히 드물기 때문에 2차원 배열을
    기준으로 강의한다.

    형식 :

    int[][] arr01 = new int[크기][크기];        - 선언 방식 # 1
    int[][] arr02 = new int[크기];             - 선언 방식 # 2
    int[][] arr03 = { {1, 2}, {3, 4}, {5, 6} };        - 선언 방식 # 3 및 초기화

    2차원 배열 선언 시, 열의 크기는 지정하지 않아도 되지만, 행의 크기는 항상 지정해야 함.
        -> 2번 방식에 해당.
        1열 2열(column)
         ↓  ↓
        {1, 2},     →   1 행(row)     가로줄을 '행'
        {3, 4},     →   2 행
        {5, 6}      →   3 행
---
         2차 배열의 element 추출 -> 중첩 for문을 사용해야한다.
        for (int i = 0 ; i < arr03.length ; i++) {
         반복문 하나 파고 들어가봐도 여전히 배열이기 때문에 이 붑누에서 1차 배열을 추출하기 위한
         반복문을 추가로 작성해야한다.
            for (int j = 0 ; j < arr03[i].length ; j++) {
                System.out.println(arr03[i][j]);
            }
        }
# JS 에서의 객체 정의 방식
```jsx
const person = {
    name : "김일",
    age : 20
};
```
이상의 형태가 python 에서는 dictionary 라는 표현을 쓰고 java 에서는 또 map 이라고 쓴다.  
person1.name = "김이";

# 제네릭(Generic)
## 개념 및 정의
    클래스나 메서드가 다룰 데이터 타입을 미리 명시해 재사용성과 유연성을 높이는 기술
## 타입 매개변수(Type Parameter)
    - 클래스나 메서드에서 사용할 실제 타입을 '대신하여 사용하는 매개변수'
    - 일반적으로 알파벳이나 대문자 하나로 표기함.
    1. T(Type) : 일반적으로 클래스 타입을 나타낼 때 사용
    2. E(Element) : 컬렉션(추후 수업)의 요소를 나타낼 때 사용
    3. K(Key) : Map(추후 수업)의 Key를 나타낼 때 사용
    4. V(Value) : Map의 Value 또는 제네릭 타입의 리턴 값으로 사용
## 재사용성
    - 제네릭을 사용하면 다양한 자료형에 대해 하나의 클래스나 메서드를 정의할 수 있어 코드의 재사용성을 높이고 중복을 줄인다.
    - 예를 들어 method overloading 개념이 있을 경우 Person 객체를 참조해 bmi를 계산한다고 가정하겠다. 
```java
package org.example;

import lombok.Builder;
import lombok.Getter;
import lombok.Setter;
import lombok.ToString;
@Setter
@Getter
@Builder
@ToString
public class Person {
    private String name;
    private double height;
    private double weight;


}
  public static void calcBmi(Person person) {
    // Person class의 각 field 들에 private을 적용했기 때문에 값을 불러오기 위해선
    // Getter를 사용해야만 한다. 근데 그럼 코드가 너무 길어져서
    double height = person.getHeight();     // 지역 변수들을
    double weight = person.getWeight();     // 선언하고 거기에 값을
    double bmi = weight/((height/100 * height/100));
    String result = "";
    System.out.println(bmi);
    if (bmi < 18.5) {
        result = "저체중";
    } else if (bmi < 23) {
        result = "정상";
    } else if (bmi < 25) {
        result = "비만 전 단계";
    } else if (bmi < 30) {
        result = "1단계 비만";
    } else if (bmi < 35) {
        result = "2단계 비만";
    } else {
        result = "3단계 비만";
    }
    System.out.println(person.getName() + "님의 BMI 지수는: " + bmi + "이므로" + result + "입니다.");

}
```
이상과 같이 쓸 수 있다. 그러면 만약에 Student 클래스가 Person 클래스를 상속 받았다고 가정할 때 Student 클래스 용으로 또 method overloading을 해야하는가와 같은 문제가 있다.
그리고 Student의 상속을 받는 MiddleSchoolStudent 라든지 HighSchoolStudent가 있으면 더 골치 아파진다.
* 참고 : 사실 upcasting이 이뤄져서 별 문제는 없다.

## 타입 안정성(Type Safety)
    - 컴파일 시점에 타입 체크를 할 수 있어 프로그램의 안정성을 높이고 명시적인 형변환을 줄임.
# Java 제네릭 와일드카드(Generic Wildcard)
## 제네릭
    - 클래스, 인터페이스, 메서드에 사용되는 자료형을 매개변수화 할 수 있도록 하는 문법으로 다양한 타입에 재사용이 가능.
```java
public class Box<T> {
    // 필드 선언
    private T value;
    public void setValue(T value) {
        this.value = value;
    }
    public T getValue() {
        return value;
    }
}
```
과 같은 방식으로 작성했을 때 value의 자료형을 고정시키지 않고 사용이 가능함.  
value에 String / Integer / Double / Product / Item ... etc 등으로 사용가능 하다.  
즉 Java 자체의 자료형(class) 뿐만 아니라 개발자가 정의한 것도 집어넣을 수 있다는 점에서 재사용성이 높다고 할 수 있다.
## 와일드 카드
    - 이상의 제네릭 타입을 사용할 때 구체적인 타입을 명시하지 않고 범욕적으로 처리하고 싶을 때 사용함. `?` 기호를 사용한다.

```java
import java.util.ArrayList;

public static void main(String[] args) {
    List<?> exampleList = new ArrayList<String>();
}
```
`<?>` 는 어떤 타입이든 가능하다는 의미다.
## 종류
    1. 모든 타입 허용
    - 읽기 전용. 어떤 타입이든지 받아야만 할 때
    2. T 또는 T의 서브 타입(자식 클래스) 
    - 읽기 전용. 제한된 타입에서 읽을 때 
    3. T 또는 T의 슈퍼 타입(부모 클래스)
    - 쓰기 전용. 제한된 타입으로 넣을 때
# Collection
    - 여러 객체를 모아놓은 것들을 의미함-> 배열과는 좀 차이가 있다.
    - 다만 Java 에서의 List는 Python 에서의 List 와도 차이가 있다.
## 종류 
    1. List : 순서가 있는 데이터의 집합으로 중복된 요소를 허락함.
    - ArrayList : 배열 기반의 리스트 요소(element) 접근 속도가 빠름.
    - LinkedList : 연결 리스트, 삽입 / 삭제 속도가 빠름.
    2. Set : 중복을 허용하지 않는(List 와의 차이 # 1) 데이터들의 집합(중1때 배우는 그 집합이다.)
    - HashSet : 해시 테이블 기반의 집합, element의 순서를 보장하지 않음(List 와의 차이 # 2)
    - TreeSet : 이진(binary) 검색 트리 기반의 집합, 요소가 정렬된 상태로 유지됨.
    3. Map : Key / Value의 쌍으로 이뤄진 데이터들의 집합
    - HashMap : 해시 테이블 기반의 맵, 키의 순서를 보장 x
    - TreeMap : 이진 검색 트리 기반의 맵, 키가 정렬된 상태로 유지
* Java 상에서의 Map의 키(Key)-값(Value) 쌍을 지칭하는 용어 : Entry
* Js 상에서 객체의 키-값 쌍을 지칭하는 용어 : Property(속성)
* 근데 문제는 Python 에서의 한국어로 속성을 지칭하는 영문 용어 : Attributes - Java 상에서의 field